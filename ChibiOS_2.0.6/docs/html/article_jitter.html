<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ChibiOS/RT: Response Time and Jitter</title>
<link href="custom.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table style="text-align: center; width: 100%;" border="0"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="width: 80px;"><img alt="ChibiOS/RT Logo" src="logo_small.png"></td>
      <td><big><big>ChibiOS/RT</big></big><br><br>Architecture - Reference Manual - Guides</td>
      <td style="width: 80px;"></td>
    </tr>
  </tbody>
</table>
<hr size="1">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">ChibiOS/RT</a>      </li>
      <li><a class="el" href="articles.html">Articles and Code Samples</a>      </li>
      <li><a class="el" href="page_general.html">General</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Response Time and Jitter </h1>  </div>
</div>
<div class="contents">
<p>Response time jitter is one of the most sneaky source of problems when designing a real time system. When using a RTOS like ChibiOS/RT one must be aware of what the jitter is and how it can affect the performance of the system. A good place to start is this <a href="http://en.wikipedia.org/wiki/Jitter" target="_blank">Wikipedia article</a>.</p>
<h2>Interrupt handlers execution time</h2>
<p>The total execution time of an interrupt handler includes:</p>
<ul>
<li>Hardware interrupts latency, this parameter is pretty much fixed and characteristic of the system.</li>
<li>Fixed handler overhead, as example registers stacking/unstacking.</li>
<li>Interrupt specific handler code execution time, as example, in a serial driver, this is the time used by the handler to transfer data from/to the UART.</li>
<li>OS overhead. Any operating system requires to run some extra code in interrupt handlers in order to handle correct preemption and Context Switching.</li>
</ul>
<h2>Interrupt Response Time</h2>
<p>The Interrupt Response Time is the time from an interrupt event and the execution of the handler code. Unfortunately this time is not constant in most cases, see the following graph:</p>
<div align="center">
<img src="inline_dotgraph_12.dot.png" alt="inline_dotgraph_12.dot" border="0" usemap="#inline_dotgraph_12.dot.map">
<map name="inline_dotgraph_12.dot.map" id="inline_dotgraph_12.dot.map"></map>
</div>
<p>In this scenario the jitter (busy state) is represented by the sum of:</p>
<ul>
<li>Higher or equal priority interrupt handlers execution time combined. This time can go from zero to the maximum randomly. This value can be guaranteed to be zero only if the interrupt has the highest priority in the system.</li>
<li>Highest execution time among lower priority handlers. This value is zero on those architectures (Cortex-M3 as example) where interrupt handlers can be preempted by higher priority sources.</li>
<li>Longest time in a kernel lock zone that can delay interrupt servicing. This value is zero for fast interrupt sources, see <a class="el" href="concepts.html#system_states">System States</a>.</li>
</ul>
<h2>Threads Flyback Time</h2>
<p>This is the time between an event, as example an interrupt, and the execution of the thread that will process it. Imagine the following graph as the continuation of the previous one.</p>
<div align="center">
<img src="inline_dotgraph_13.dot.png" alt="inline_dotgraph_13.dot" border="0" usemap="#inline_dotgraph_13.dot.map">
<map name="inline_dotgraph_13.dot.map" id="inline_dotgraph_13.dot.map"></map>
</div>
<p>In this scenario all the jitter sources previously discussed are also present and there is the added jitter caused by the activity of the higher priority threads.</p>
<h2>Jitter Mitigation</h2>
<p>For each of the previously described jitter sources there are possible mitigation actions.</p>
<h3>Interrupt handlers optimization</h3>
<p>An obvious mitigation action is to optimize the interrupt handler code as much as possible for speed.<br/>
 Complex actions should never be performed in interrupt handlers. An handler should just serve the interrupt and wakeup a dedicated thread in order to handle the bulk of the work.<br/>
 Another possible mitigation action is to evaluate if a specific interrupt handler really needs to interact with the OS, if the handler uses full stand-alone code then it is possible to remove the OS related overhead.<br/>
</p>
<h3>Kernel lock zones</h3>
<p>The OS kernel protects some critical internal data structure by disabling (fully in simple architecture, to some extent in more advanced microcontrollers) the interrupt sources. Because of this the kernel itself is a jitter cause, a good OS design minimizes the jitter generated by the kernel by using adequate data structures, algorithms and coding practices.<br/>
 A good OS design is not the whole story, some OS primitives may generate more or less jitter depending on the system state, as example the maximum number of threads on a certain queue, the maximum number of nested mutexes and so on. Some algorithms employed internally can have constant execution time but others may have linear execution time or be even more complex.</p>
<h3>Higher priority threads activity</h3>
<p>At thread level, the response time is affected by the interrupt-related jitter but mainly by the activity of the higher priority threads and contention on protected resources.<br/>
 It is possible to improve the system overall response time and reduce jitter by carefully assigning priorities to the various threads and carefully designing mutual exclusion zones.<br/>
 The use of the proper synchronization mechanism (semaphores, mutexes, events, messages and so on) also helps to improve the overall system performance. The use of the Priority Inheritance algorithm implemented in the mutexes subsystem can improve the overall response time and reduce jitter but it is not a magic wand, a proper system design comes first. </p>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Oct 24 2010 09:40:45 for ChibiOS/RT by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1</small></address>
</body>
</html>
