<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ChibiOS/RT: Kernel Concepts</title>
<link href="custom.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table style="text-align: center; width: 100%;" border="0"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="width: 80px;"><img alt="ChibiOS/RT Logo" src="logo_small.png"></td>
      <td><big><big>ChibiOS/RT</big></big><br><br>Architecture - Reference Manual - Guides</td>
      <td style="width: 80px;"></td>
    </tr>
  </tbody>
</table>
<hr size="1">
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">ChibiOS/RT</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="concepts">Kernel Concepts </a></h1><p>ChibiOS/RT Kernel Concepts</p>
<ul>
<li><a class="el" href="concepts.html#naming">Naming Conventions</a></li>
<li><a class="el" href="concepts.html#api_suffixes">API Names Suffixes</a></li>
<li><a class="el" href="concepts.html#interrupt_classes">Interrupt Classes</a></li>
<li><a class="el" href="concepts.html#system_states">System States</a></li>
<li><a class="el" href="concepts.html#scheduling">Scheduling</a></li>
<li><a class="el" href="concepts.html#thread_states">Threads States</a></li>
<li><a class="el" href="concepts.html#priority">Priority Levels</a></li>
<li><a class="el" href="concepts.html#warea">Threads Working Area</a></li>
</ul>
<h2><a class="anchor" id="naming">
Naming Conventions</a></h2>
<p>ChibiOS/RT APIs are all named following this convention: <em>ch&lt;group&gt;&lt;action&gt;&lt;suffix&gt;</em>(). The possible groups are: <em>Sys</em>, <em>Sch</em>, <em>Time</em>, <em>VT</em>, <em>Thd</em>, <em>Sem</em>, <em>Mtx</em>, <em>Cond</em>, <em>Evt</em>, <em>Msg</em>, <em>SequentialStream</em>, <em>IO</em>, <em>IQ</em>, <em>OQ</em>, <em>Dbg</em>, <em>Core</em>, <em>Heap</em>, <em>Pool</em>.</p>
<h2><a class="anchor" id="api_suffixes">
API Names Suffixes</a></h2>
<p>The suffix can be one of the following:</p>
<ul>
<li><b>None</b>, APIs without any suffix can be invoked only from the user code in the <b>Normal</b> state unless differently specified. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
<li><a class="anchor" id="I-Class"></a> <b>"I"</b>, I-Class APIs are invokable only from the <b>I-Locked</b> or <b>S-Locked</b> states. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
<li><a class="anchor" id="S-Class"></a> <b>"S"</b>, S-Class APIs are invokable only from the <b>S-Locked</b> state. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
</ul>
<p>Examples: <code><a class="el" href="group__threads.html#ga048e588238dd336c6059133b3d0c3435" title="Creates a new thread into a static memory area.">chThdCreateStatic()</a></code>, <code><a class="el" href="group__semaphores.html#gaca0b70cf495a9cb7569e1cf5b07e2b3d" title="Performs a signal operation on a semaphore.">chSemSignalI()</a></code>, <code><a class="el" href="group__io__queues.html#ga142d0e885ac3a695f5f033a65f49abd0" title="Input queue read with timeout.">chIQGetTimeout()</a></code>.</p>
<h2><a class="anchor" id="interrupt_classes">
Interrupt Classes</a></h2>
<p>In ChibiOS/RT there are three logical interrupt classes:</p>
<ul>
<li><b>Regular Interrupts</b>. Maskable interrupt sources that cannot preempt (small parts of) the kernel code and are thus able to invoke operating system APIs from within their handlers. The interrupt handlers belonging to this class must be written following some rules. See the <a class="el" href="group__system.html">System Management</a> APIs group and <a class="el" href="article__interrupts.html">How to write interrupt handlers</a>.</li>
<li><b>Fast Interrupts</b>. Maskable interrupt sources with the ability to preempt the kernel code and thus have a lower latency and are less subject to jitter, see <a class="el" href="article__jitter.html">Response Time and Jitter</a>. Such sources are not supported on all the architectures.<br/>
 Fast interrupts are not allowed to invoke any operating system API from within their handlers. Fast interrupt sources may, however, pend a lower priority regular interrupt where access to the operating system is possible.</li>
<li><b>Non Maskable Interrupts</b>. Non maskable interrupt sources are totally out of the operating system control and have the lowest latency. Such sources are not supported on all the architectures.</li>
</ul>
<p>The mapping of the above logical classes into physical interrupts priorities is, of course, port dependent. See the documentation of the various ports for details.</p>
<h2><a class="anchor" id="system_states">
System States</a></h2>
<p>When using ChibiOS/RT the system can be in one of the following logical operating states:</p>
<ul>
<li><b>Init</b>. When the system is in this state all the maskable interrupt sources are disabled. In this state it is not possible to use any system API except <code><a class="el" href="group__system.html#gafe2c7de6567e98e487e009e81e3be10b" title="ChibiOS/RT initialization.">chSysInit()</a></code>. This state is entered after a physical reset.</li>
<li><b>Normal</b>. All the interrupt sources are enabled and the system APIs are accessible, threads are running.</li>
<li><b>Suspended</b>. In this state the fast interrupt sources are enabled but the regular interrupt sources are not. In this state it is not possible to use any system API except <code><a class="el" href="group__system.html#ga0f6e07fb701e2006ba40db2ede3a4b5b" title="Raises the system interrupt priority mask to the maximum level.">chSysDisable()</a></code> or <code><a class="el" href="group__system.html#ga2f54701f43490a5de272cc3d32962b51" title="Lowers the system interrupt priority mask to user level.">chSysEnable()</a></code> in order to change state.</li>
<li><b>Disabled</b>. When the system is in this state both the maskable regular and fast interrupt sources are disabled. In this state it is not possible to use any system API except <code><a class="el" href="group__system.html#ga345a8b0ef36155654e5cf88a853365b4" title="Raises the system interrupt priority mask to system level.">chSysSuspend()</a></code> or <code><a class="el" href="group__system.html#ga2f54701f43490a5de272cc3d32962b51" title="Lowers the system interrupt priority mask to user level.">chSysEnable()</a></code> in order to change state.</li>
<li><b>Sleep</b>. Architecture-dependent low power mode, the idle thread goes in this state and waits for interrupts, after servicing the interrupt the Normal state is restored and the scheduler has a chance to reschedule.</li>
<li><b>S-Locked</b>. Kernel locked and regular interrupt sources disabled. Fast interrupt sources are enabled. <a class="el" href="concepts.html#S-Class">S-Class</a> and <a class="el" href="concepts.html#I-Class">I-Class</a> APIs are invokable in this state.</li>
<li><b>I-Locked</b>. Kernel locked and regular interrupt sources disabled. <a class="el" href="concepts.html#I-Class">I-Class</a> APIs are invokable from this state.</li>
<li><b>Serving Regular Interrupt</b>. No system APIs are accessible but it is possible to switch to the I-Locked state using <code><a class="el" href="group__system.html#gab826c6d946aa1eb839751246ea158a72" title="Enters the kernel lock mode from within an interrupt handler.">chSysLockFromIsr()</a></code> and then invoke any <a class="el" href="concepts.html#I-Class">I-Class</a> API. Interrupt handlers can be preemptable on some architectures thus is important to switch to I-Locked state before invoking system APIs.</li>
<li><b>Serving Fast Interrupt</b>. System APIs are not accessible.</li>
<li><b>Serving Non-Maskable Interrupt</b>. System APIs are not accessible.</li>
<li><b>Halted</b>. All interrupt sources are disabled and system stopped into an infinite loop. This state can be reached if the debug mode is activated <b>and</b> an error is detected <b>or</b> after explicitly invoking <code><a class="el" href="group__system.html#gad43b78f160a2c983792af3041cc4a536" title="Halts the system.">chSysHalt()</a></code>.</li>
</ul>
<p>Note that the above states are just <b>Logical States</b> that may have no real associated machine state on some architectures. The following diagram shows the possible transitions between the states:</p>
<div align="center">
<img src="inline_dotgraph_6.dot.png" alt="inline_dotgraph_6.dot" border="0" usemap="#inline_dotgraph_6.dot.map">
<map name="inline_dotgraph_6.dot.map" id="inline_dotgraph_6.dot.map"></map>
</div>
<p> Note, the <b>SFI</b>, <b>Halted</b> and <b>SNMI</b> states were not shown because those are reachable from most states:</p>
<div align="center">
<img src="inline_dotgraph_7.dot.png" alt="inline_dotgraph_7.dot" border="0" usemap="#inline_dotgraph_7.dot.map">
<map name="inline_dotgraph_7.dot.map" id="inline_dotgraph_7.dot.map"></map>
</div>
 <dl class="attention"><dt><b>Attention:</b></dt><dd>* except: <b>Init</b>, <b>Halt</b>, <b>SNMI</b>, <b>Disabled</b>.</dd></dl>
<h2><a class="anchor" id="scheduling">
Scheduling</a></h2>
<p>The strategy is very simple the currently ready thread with the highest priority is executed. If more than one thread with equal priority are eligible for execution then they are executed in a round-robin way, the CPU time slice constant is configurable. The ready list is a double linked list of threads ordered by priority.<br/>
<br/>
 </p>
<div align="center">
<img src="inline_dotgraph_8.dot.png" alt="inline_dotgraph_8.dot" border="0" usemap="#inline_dotgraph_8.dot.map">
<map name="inline_dotgraph_8.dot.map" id="inline_dotgraph_8.dot.map"></map>
</div>
<p> <br/>
 Note that the currently running thread is not in the ready list, the list only contains the threads ready to be executed but still actually waiting.</p>
<h2><a class="anchor" id="thread_states">
Threads States</a></h2>
<p>The image shows how threads can change their state in ChibiOS/RT.<br/>
 </p>
<div align="center">
<img src="inline_dotgraph_9.dot.png" alt="inline_dotgraph_9.dot" border="0" usemap="#inline_dotgraph_9.dot.map">
<map name="inline_dotgraph_9.dot.map" id="inline_dotgraph_9.dot.map"></map>
</div>
<h2><a class="anchor" id="priority">
Priority Levels</a></h2>
<p>Priorities in ChibiOS/RT are a contiguous numerical range but the initial and final values are not enforced.<br/>
 The following table describes the various priority boundaries (from lowest to highest):</p>
<ul>
<li><code>IDLEPRIO</code>, this is the lowest priority level and is reserved for the idle thread, no other threads should share this priority level. This is the lowest numerical value of the priorities space.</li>
<li><code>LOWPRIO</code>, the lowest priority level that can be assigned to an user thread.</li>
<li><code>NORMALPRIO</code>, this is the central priority level for user threads. It is advisable to assign priorities to threads as values relative to <code>NORMALPRIO</code>, as example NORMALPRIO-1 or NORMALPRIO+4, this ensures the portability of code should the numerical range change in future implementations.</li>
<li><code>HIGHPRIO</code>, the highest priority level that can be assigned to an user thread.</li>
<li><code>ABSPRO</code>, absolute maximum software priority level, it can be higher than <code>HIGHPRIO</code> but the numerical values above <code>HIGHPRIO</code> up to <code>ABSPRIO</code> (inclusive) are reserved. This is the highest numerical value of the priorities space.</li>
</ul>
<h2><a class="anchor" id="warea">
Threads Working Area</a></h2>
<p>Each thread has its own stack, a <a class="el" href="struct_thread.html" title="Structure representing a thread.">Thread</a> structure and some preemption areas. All the structures are allocated into a "Thread Working Area", a thread private heap, usually statically declared in your code. Threads do not use any memory outside the allocated working area except when accessing static shared data.<br/>
<br/>
 </p>
<div align="center">
<img src="workspace.png" alt="workspace.png"/>
</div>
<p> <br/>
 Note that the preemption area is only present when the thread is not running (switched out), the context switching is done by pushing the registers on the stack of the switched-out thread and popping the registers of the switched-in thread from its stack. The preemption area can be divided in up to three structures:</p>
<ul>
<li>External Context.</li>
<li>Interrupt Stack.</li>
<li>Internal Context.</li>
</ul>
<p>See the <a class="el" href="group__core.html">Port Templates</a> documentation for details, the area may change on the various ports and some structures may not be present (or be zero-sized). </p>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jul 11 13:13:08 2010 for ChibiOS/RT by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.6.3</small></address>
</body>
</html>
